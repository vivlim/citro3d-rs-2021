/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u32 = 8;
pub const C3D_FVUNIF_COUNT: u32 = 96;
pub const C3D_IVUNIF_COUNT: u32 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub const C2D_DEFAULT_MAX_OBJECTS: u32 = 4096;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type size_t = ::libc::c_uint;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s32 = i32;
pub type Result = s32;
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
#[doc = "< Top screen"]
pub const GFX_TOP: gfxScreen_t = 0;
#[doc = "< Bottom screen"]
pub const GFX_BOTTOM: gfxScreen_t = 1;
#[doc = " Screen IDs."]
pub type gfxScreen_t = ::libc::c_uint;
#[doc = "< Left eye framebuffer"]
pub const GFX_LEFT: gfx3dSide_t = 0;
#[doc = "< Right eye framebuffer"]
pub const GFX_RIGHT: gfx3dSide_t = 1;
#[doc = " @brief Top screen framebuffer side."]
#[doc = ""]
#[doc = " This is only meaningful when stereoscopic 3D is enabled on the top screen."]
#[doc = " In any other case, use \\ref GFX_LEFT."]
pub type gfx3dSide_t = ::libc::c_uint;
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type wint_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
    _bindgen_union_align: u32,
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "< Japan"]
pub const CFG_REGION_JPN: CFG_Region = 0;
#[doc = "< USA"]
pub const CFG_REGION_USA: CFG_Region = 1;
#[doc = "< Europe"]
pub const CFG_REGION_EUR: CFG_Region = 2;
#[doc = "< Australia"]
pub const CFG_REGION_AUS: CFG_Region = 3;
#[doc = "< China"]
pub const CFG_REGION_CHN: CFG_Region = 4;
#[doc = "< Korea"]
pub const CFG_REGION_KOR: CFG_Region = 5;
#[doc = "< Taiwan"]
pub const CFG_REGION_TWN: CFG_Region = 6;
#[doc = " Configuration region values."]
pub type CFG_Region = ::libc::c_uint;
pub type __ULong = ::libc::c_ulong;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 30usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for _reent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
#[doc = " @brief Supported transfer pixel formats."]
#[doc = " @sa GSPGPU_FramebufferFormat"]
pub type GX_TRANSFER_FORMAT = ::libc::c_uint;
#[doc = "< No anti-aliasing"]
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
#[doc = "< 2x1 anti-aliasing"]
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
#[doc = "< 2x2 anti-aliasing"]
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
#[doc = " @brief Anti-aliasing modes"]
#[doc = ""]
#[doc = " Please remember that the framebuffer is sideways."]
#[doc = " Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400"]
pub type GX_TRANSFER_SCALE = ::libc::c_uint;
#[doc = "< Trigger the PPF event"]
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
#[doc = "< Indicates if the memory fill is complete. You should not use it when requesting a transfer."]
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
#[doc = "< The buffer has a 16 bit per pixel depth"]
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
#[doc = "< The buffer has a 24 bit per pixel depth"]
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
#[doc = "< The buffer has a 32 bit per pixel depth"]
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
#[doc = " GX transfer control flags"]
pub type GX_FILL_CONTROL = ::libc::c_uint;
#[doc = " GX command entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union gxCmdEntry_s {
    #[doc = "< Raw command data"]
    pub data: [u32_; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    #[doc = "< Command type"]
    pub type_: u8_,
    pub unk1: u8_,
    pub unk2: u8_,
    pub unk3: u8_,
    #[doc = "< Command arguments"]
    pub args: [u32_; 7usize],
}
impl Default for gxCmdEntry_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " GX command queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_gxCmdQueue_s {
    #[doc = "< Pointer to array of GX command entries"]
    pub entries: *mut gxCmdEntry_s,
    #[doc = "< Capacity of the command array"]
    pub maxEntries: u16_,
    #[doc = "< Number of commands in the queue"]
    pub numEntries: u16_,
    #[doc = "< Index of the first pending command to be submitted to GX"]
    pub curEntry: u16_,
    #[doc = "< Number of commands completed by GX"]
    pub lastEntry: u16_,
    #[doc = "< User callback"]
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    #[doc = "< Data for user callback"]
    pub user: *mut ::libc::c_void,
}
impl Default for tag_gxCmdQueue_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " GX command queue structure"]
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    #[doc = " @brief Selects a command queue to which GX_* functions will add commands instead of immediately submitting them to GX."]
    #[doc = " @param queue The GX command queue. (Pass NULL to remove the bound command queue)"]
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = " @brief Requests a DMA."]
    #[doc = " @param src Source to DMA from."]
    #[doc = " @param dst Destination to DMA to."]
    #[doc = " @param length Length of data to transfer."]
    pub fn GX_RequestDma(src: *mut u32_, dst: *mut u32_, length: u32_) -> Result;
}
extern "C" {
    #[doc = " @brief Processes a GPU command list."]
    #[doc = " @param buf0a Command list address."]
    #[doc = " @param buf0s Command list size."]
    #[doc = " @param flags Flags to process with."]
    pub fn GX_ProcessCommandList(buf0a: *mut u32_, buf0s: u32_, flags: u8_) -> Result;
}
extern "C" {
    #[doc = " @brief Fills the memory of two buffers with the given values."]
    #[doc = " @param buf0a Start address of the first buffer."]
    #[doc = " @param buf0v Dimensions of the first buffer."]
    #[doc = " @param buf0e End address of the first buffer."]
    #[doc = " @param control0 Value to fill the first buffer with."]
    #[doc = " @param buf1a Start address of the second buffer."]
    #[doc = " @param buf1v Dimensions of the second buffer."]
    #[doc = " @param buf1e End address of the second buffer."]
    #[doc = " @param control1 Value to fill the second buffer with."]
    pub fn GX_MemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    ) -> Result;
}
extern "C" {
    #[doc = " @brief Initiates a display transfer."]
    #[doc = " @note The PPF event will be signaled on completion."]
    #[doc = " @param inadr Address of the input."]
    #[doc = " @param indim Dimensions of the input."]
    #[doc = " @param outadr Address of the output."]
    #[doc = " @param outdim Dimensions of the output."]
    #[doc = " @param flags Flags to transfer with."]
    pub fn GX_DisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[doc = " @brief Initiates a texture copy."]
    #[doc = " @note The PPF event will be signaled on completion."]
    #[doc = " @param inadr Address of the input."]
    #[doc = " @param indim Dimensions of the input."]
    #[doc = " @param outadr Address of the output."]
    #[doc = " @param outdim Dimensions of the output."]
    #[doc = " @param size Size of the data to transfer."]
    #[doc = " @param flags Flags to transfer with."]
    pub fn GX_TextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[doc = " @brief Flushes the cache regions of three buffers. (This command cannot be queued in a GX command queue)"]
    #[doc = " @param buf0a Address of the first buffer."]
    #[doc = " @param buf0s Size of the first buffer."]
    #[doc = " @param buf1a Address of the second buffer."]
    #[doc = " @param buf1s Size of the second buffer."]
    #[doc = " @param buf2a Address of the third buffer."]
    #[doc = " @param buf2s Size of the third buffer."]
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32_,
        buf0s: u32_,
        buf1a: *mut u32_,
        buf1s: u32_,
        buf2a: *mut u32_,
        buf2s: u32_,
    ) -> Result;
}
#[doc = "< 2D texture"]
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
#[doc = "< Cube map"]
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
#[doc = "< 2D Shadow texture"]
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
#[doc = "< Projection texture"]
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
#[doc = "< Shadow cube map"]
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
#[doc = "< Disabled"]
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
#[doc = " Texture modes."]
pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
#[doc = "< 8-bit Luminance + 8-bit Alpha"]
pub const GPU_LA8: GPU_TEXCOLOR = 5;
#[doc = "< 8-bit Hi + 8-bit Lo"]
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
#[doc = "< 8-bit Luminance"]
pub const GPU_L8: GPU_TEXCOLOR = 7;
#[doc = "< 8-bit Alpha"]
pub const GPU_A8: GPU_TEXCOLOR = 8;
#[doc = "< 4-bit Luminance + 4-bit Alpha"]
pub const GPU_LA4: GPU_TEXCOLOR = 9;
#[doc = "< 4-bit Luminance"]
pub const GPU_L4: GPU_TEXCOLOR = 10;
#[doc = "< 4-bit Alpha"]
pub const GPU_A4: GPU_TEXCOLOR = 11;
#[doc = "< ETC1 texture compression"]
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
#[doc = "< ETC1 texture compression + 4-bit Alpha"]
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
#[doc = " Supported texture formats."]
pub type GPU_TEXCOLOR = ::libc::c_uint;
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
pub type GPU_TEXFACE = ::libc::c_uint;
#[doc = "< Noise table"]
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
#[doc = "< RGB mapping function table"]
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
#[doc = "< Alpha mapping function table"]
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
#[doc = "< Color table"]
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
#[doc = "< Color difference table"]
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
#[doc = " Procedural texture LUT IDs."]
pub type GPU_PROCTEX_LUTID = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
#[doc = " Supported color buffer formats."]
pub type GPU_COLORBUF = ::libc::c_uint;
#[doc = "< 16-bit Depth"]
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
#[doc = "< 24-bit Depth"]
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
#[doc = "< 24-bit Depth + 8-bit Stencil"]
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
#[doc = " Supported depth buffer formats."]
pub type GPU_DEPTHBUF = ::libc::c_uint;
#[doc = "< Never pass."]
pub const GPU_NEVER: GPU_TESTFUNC = 0;
#[doc = "< Always pass."]
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
#[doc = "< Pass if equal."]
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
#[doc = "< Pass if not equal."]
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
#[doc = "< Pass if less than."]
pub const GPU_LESS: GPU_TESTFUNC = 4;
#[doc = "< Pass if less than or equal."]
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
#[doc = "< Pass if greater than."]
pub const GPU_GREATER: GPU_TESTFUNC = 6;
#[doc = "< Pass if greater than or equal."]
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
#[doc = " Test functions."]
pub type GPU_TESTFUNC = ::libc::c_uint;
#[doc = "< Pass if greater than or equal."]
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
#[doc = "< Pass if greater than."]
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
#[doc = "< Pass if less than or equal."]
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
#[doc = "< Pass if less than."]
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
#[doc = " Early depth test functions."]
pub type GPU_EARLYDEPTHFUNC = ::libc::c_uint;
#[doc = "< Disable."]
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
#[doc = "< Exclude pixels inside the scissor box."]
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
#[doc = "< Exclude pixels outside of the scissor box."]
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
#[doc = " Scissor test modes."]
pub type GPU_SCISSORMODE = ::libc::c_uint;
#[doc = "< Keep old value. (old_stencil)"]
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
#[doc = "< Zero. (0)"]
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
#[doc = "< Replace value. (ref)"]
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
#[doc = "< Increment value. (old_stencil + 1 saturated to [0, 255])"]
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
#[doc = "< Decrement value. (old_stencil - 1 saturated to [0, 255])"]
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
#[doc = "< Invert value. (~old_stencil)"]
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
#[doc = "< Increment value. (old_stencil + 1)"]
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
#[doc = "< Decrement value. (old_stencil - 1)"]
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
#[doc = " Stencil operations."]
pub type GPU_STENCILOP = ::libc::c_uint;
#[doc = "< Write red."]
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
#[doc = "< Write green."]
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
#[doc = "< Write blue."]
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
#[doc = "< Write alpha."]
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
#[doc = "< Write depth."]
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
#[doc = "< Write all color components."]
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
#[doc = "< Write all components."]
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
#[doc = " Pixel write mask."]
pub type GPU_WRITEMASK = ::libc::c_uint;
#[doc = "< Add colors."]
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
#[doc = "< Subtract colors."]
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
#[doc = "< Reverse-subtract colors."]
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
#[doc = "< Use the minimum color."]
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
#[doc = "< Use the maximum color."]
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
#[doc = " Blend modes."]
pub type GPU_BLENDEQUATION = ::libc::c_uint;
#[doc = "< Zero."]
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
#[doc = "< One."]
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
#[doc = "< Source color."]
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
#[doc = "< Source color - 1."]
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
#[doc = "< Destination color."]
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
#[doc = "< Destination color - 1."]
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
#[doc = "< Source alpha."]
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
#[doc = "< Source alpha - 1."]
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
#[doc = "< Destination alpha."]
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
#[doc = "< Destination alpha - 1."]
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
#[doc = "< Constant color."]
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
#[doc = "< Constant color - 1."]
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
#[doc = "< Constant alpha."]
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
#[doc = "< Constant alpha - 1."]
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
#[doc = "< Saturated alpha."]
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
#[doc = " Blend factors."]
pub type GPU_BLENDFACTOR = ::libc::c_uint;
#[doc = "< Clear."]
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
#[doc = "< Bitwise AND."]
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
#[doc = "< Reverse bitwise AND."]
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
#[doc = "< Copy."]
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
#[doc = "< Set."]
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
#[doc = "< Inverted copy."]
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
#[doc = "< No operation."]
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
#[doc = "< Invert."]
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
#[doc = "< Bitwise NAND."]
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
#[doc = "< Bitwise OR."]
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
#[doc = "< Bitwise NOR."]
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
#[doc = "< Bitwise XOR."]
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
#[doc = "< Equivalent."]
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
#[doc = "< Inverted bitwise AND."]
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
#[doc = "< Reverse bitwise OR."]
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
#[doc = "< Inverted bitwize OR."]
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
#[doc = " Logical operations."]
pub type GPU_LOGICOP = ::libc::c_uint;
#[doc = "< OpenGL mode."]
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
#[doc = "< Gas mode (?)."]
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
#[doc = "< Shadow mode (?)."]
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
#[doc = " Fragment operation modes."]
pub type GPU_FRAGOPMODE = ::libc::c_uint;
#[doc = "< 8-bit byte."]
pub const GPU_BYTE: GPU_FORMATS = 0;
#[doc = "< 8-bit unsigned byte."]
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
#[doc = "< 16-bit short."]
pub const GPU_SHORT: GPU_FORMATS = 2;
#[doc = "< 32-bit float."]
pub const GPU_FLOAT: GPU_FORMATS = 3;
#[doc = " Supported component formats."]
pub type GPU_FORMATS = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
#[doc = "< Front, counter-clockwise."]
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
#[doc = "< Back, counter-clockwise."]
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
#[doc = " Cull modes."]
pub type GPU_CULLMODE = ::libc::c_uint;
#[doc = "< None."]
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
#[doc = "< Primary alpha."]
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
#[doc = "< Secondary alpha."]
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
#[doc = "< Primary and secondary alpha."]
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
#[doc = " Fresnel options."]
pub type GPU_FRESNELSEL = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
#[doc = "< Bump as bump mapping."]
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
#[doc = "< Bump as tangent/normal mapping."]
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
#[doc = " Bump map modes."]
pub type GPU_BUMPMODE = ::libc::c_uint;
#[doc = "< D0 LUT."]
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
#[doc = "< D1 LUT."]
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
#[doc = "< Spotlight LUT."]
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
#[doc = "< Fresnel LUT."]
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
#[doc = "< Reflection-Blue LUT."]
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
#[doc = "< Reflection-Green LUT."]
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
#[doc = "< Reflection-Red LUT."]
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
#[doc = " LUT IDs."]
pub type GPU_LIGHTLUTID = ::libc::c_uint;
#[doc = "< Normal*HalfVector"]
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
#[doc = "< View*HalfVector"]
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
#[doc = "< Normal*View"]
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
#[doc = "< LightVector*Normal"]
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
#[doc = "< -LightVector*SpotlightVector"]
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
#[doc = "< cosine of phi"]
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
#[doc = " LUT inputs."]
pub type GPU_LIGHTLUTINPUT = ::libc::c_uint;
#[doc = "< Fog/Gas unit disabled."]
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
#[doc = "< Fog/Gas unit configured in Fog mode."]
pub const GPU_FOG: GPU_FOGMODE = 5;
#[doc = "< Fog/Gas unit configured in Gas mode."]
pub const GPU_GAS: GPU_FOGMODE = 7;
#[doc = " Fog modes."]
pub type GPU_FOGMODE = ::libc::c_uint;
#[doc = "< Plain density."]
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
#[doc = "< Depth density."]
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
#[doc = " Gas shading density source values."]
pub type GPU_GASMODE = ::libc::c_uint;
#[doc = "< Gas density used as input."]
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
#[doc = "< Light factor used as input."]
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
#[doc = " Gas color LUT inputs."]
pub type GPU_GASLUTINPUT = ::libc::c_uint;
#[doc = "< Triangles."]
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
#[doc = "< Triangle strip."]
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
#[doc = "< Triangle fan."]
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
#[doc = "< Geometry shader primitive."]
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
#[doc = " Supported primitives."]
pub type GPU_Primitive_t = ::libc::c_uint;
#[doc = "< Vertex shader."]
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
#[doc = "< Geometry shader."]
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
#[doc = " Shader types."]
pub type GPU_SHADER_TYPE = ::libc::c_uint;
#[doc = "< Vertex shader."]
pub const VERTEX_SHDR: DVLE_type = 0;
#[doc = "< Geometry shader."]
pub const GEOMETRY_SHDR: DVLE_type = 1;
#[doc = " DVLE type."]
pub type DVLE_type = ::libc::c_uint;
#[doc = "< Point processing mode."]
pub const GSH_POINT: DVLE_geoShaderMode = 0;
#[doc = "< Variable-size primitive processing mode."]
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
#[doc = "< Fixed-size primitive processing mode."]
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
#[doc = " Geometry shader operation modes."]
pub type DVLE_geoShaderMode = ::libc::c_uint;
#[doc = " DVLP data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    #[doc = "< Code size."]
    pub codeSize: u32_,
    #[doc = "< Code data."]
    pub codeData: *mut u32_,
    #[doc = "< Operand description size."]
    pub opdescSize: u32_,
    #[doc = "< Operand description data."]
    pub opcdescData: *mut u32_,
}
impl Default for DVLP_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " DVLE constant entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_constEntry_s {
    #[doc = "< Constant type. See @ref DVLE_constantType"]
    pub type_: u16_,
    #[doc = "< Constant ID."]
    pub id: u16_,
    #[doc = "< Constant data."]
    pub data: [u32_; 4usize],
}
#[doc = " DVLE output entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_outEntry_s {
    #[doc = "< Output type. See @ref DVLE_outputAttribute_t"]
    pub type_: u16_,
    #[doc = "< Output register ID."]
    pub regID: u16_,
    #[doc = "< Output mask."]
    pub mask: u8_,
    #[doc = "< Unknown."]
    pub unk: [u8_; 3usize],
}
#[doc = " DVLE uniform entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    #[doc = "< Symbol offset."]
    pub symbolOffset: u32_,
    #[doc = "< Start register."]
    pub startReg: u16_,
    #[doc = "< End register."]
    pub endReg: u16_,
}
#[doc = " DVLE data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    #[doc = "< DVLE type."]
    pub type_: DVLE_type,
    #[doc = "< true = merge vertex/geometry shader outmaps ('dummy' output attribute is present)."]
    pub mergeOutmaps: bool,
    #[doc = "< Geometry shader operation mode."]
    pub gshMode: DVLE_geoShaderMode,
    #[doc = "< Starting float uniform register number for storing the fixed-size primitive vertex array."]
    pub gshFixedVtxStart: u8_,
    #[doc = "< Number of fully-defined vertices in the variable-size primitive vertex array."]
    pub gshVariableVtxNum: u8_,
    #[doc = "< Number of vertices in the fixed-size primitive vertex array."]
    pub gshFixedVtxNum: u8_,
    #[doc = "< Contained DVLPs."]
    pub dvlp: *mut DVLP_s,
    #[doc = "< Offset of the start of the main function."]
    pub mainOffset: u32_,
    #[doc = "< Offset of the end of the main function."]
    pub endmainOffset: u32_,
    #[doc = "< Constant table size."]
    pub constTableSize: u32_,
    #[doc = "< Constant table data."]
    pub constTableData: *mut DVLE_constEntry_s,
    #[doc = "< Output table size."]
    pub outTableSize: u32_,
    #[doc = "< Output table data."]
    pub outTableData: *mut DVLE_outEntry_s,
    #[doc = "< Uniform table size."]
    pub uniformTableSize: u32_,
    #[doc = "< Uniform table data."]
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    #[doc = "< Symbol table data."]
    pub symbolTableData: *mut ::libc::c_char,
    #[doc = "< Output map mask."]
    pub outmapMask: u8_,
    #[doc = "< Output map data."]
    pub outmapData: [u32_; 8usize],
    #[doc = "< Output map mode."]
    pub outmapMode: u32_,
    #[doc = "< Output map attribute clock."]
    pub outmapClock: u32_,
}
impl Default for DVLE_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " DVLB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    #[doc = "< DVLE count."]
    pub numDVLE: u32_,
    #[doc = "< Primary DVLP."]
    pub DVLP: DVLP_s,
    #[doc = "< Contained DVLE."]
    pub DVLE: *mut DVLE_s,
}
impl Default for DVLB_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " @brief Parses a shader binary."]
    #[doc = " @param shbinData Shader binary data."]
    #[doc = " @param shbinSize Shader binary size."]
    #[doc = " @return The parsed shader binary."]
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
extern "C" {
    #[doc = " @brief Frees shader binary data."]
    #[doc = " @param dvlb DVLB to free."]
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
#[doc = " 24-bit float uniforms."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct float24Uniform_s {
    #[doc = "< Uniform ID."]
    pub id: u32_,
    #[doc = "< Uniform data."]
    pub data: [u32_; 3usize],
}
#[doc = " Describes an instance of either a vertex or geometry shader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    #[doc = "< Shader DVLE."]
    pub dvle: *mut DVLE_s,
    #[doc = "< Boolean uniforms."]
    pub boolUniforms: u16_,
    #[doc = "< Used boolean uniform mask."]
    pub boolUniformMask: u16_,
    #[doc = "< Integer uniforms."]
    pub intUniforms: [u32_; 4usize],
    #[doc = "< 24-bit float uniforms."]
    pub float24Uniforms: *mut float24Uniform_s,
    #[doc = "< Used integer uniform mask."]
    pub intUniformMask: u8_,
    #[doc = "< Float uniform count."]
    pub numFloat24Uniforms: u8_,
}
impl Default for shaderInstance_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Describes an instance of a full shader program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    #[doc = "< Vertex shader."]
    pub vertexShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader."]
    pub geometryShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader input permutation."]
    pub geoShaderInputPermutation: [u32_; 2usize],
    #[doc = "< Geometry shader input stride."]
    pub geoShaderInputStride: u8_,
}
impl Default for shaderProgram_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Character width information structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct charWidthInfo_s {
    #[doc = "< Horizontal offset to draw the glyph with."]
    pub left: s8,
    #[doc = "< Width of the glyph."]
    pub glyphWidth: u8_,
    #[doc = "< Width of the character, that is, horizontal distance to advance."]
    pub charWidth: u8_,
}
#[doc = " Font texture sheet information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TGLP_s {
    #[doc = "< Width of a glyph cell."]
    pub cellWidth: u8_,
    #[doc = "< Height of a glyph cell."]
    pub cellHeight: u8_,
    #[doc = "< Vertical position of the baseline."]
    pub baselinePos: u8_,
    #[doc = "< Maximum character width."]
    pub maxCharWidth: u8_,
    #[doc = "< Size in bytes of a texture sheet."]
    pub sheetSize: u32_,
    #[doc = "< Number of texture sheets."]
    pub nSheets: u16_,
    #[doc = "< GPU texture format (GPU_TEXCOLOR)."]
    pub sheetFmt: u16_,
    #[doc = "< Number of glyphs per row per sheet."]
    pub nRows: u16_,
    #[doc = "< Number of glyph rows per sheet."]
    pub nLines: u16_,
    #[doc = "< Texture sheet width."]
    pub sheetWidth: u16_,
    #[doc = "< Texture sheet height."]
    pub sheetHeight: u16_,
    #[doc = "< Pointer to texture sheet data."]
    pub sheetData: *mut u8_,
}
impl Default for TGLP_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Font character width information block type."]
pub type CWDH_s = tag_CWDH_s;
#[doc = " Font character width information block structure."]
#[repr(C)]
#[derive(Debug)]
pub struct tag_CWDH_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub startIndex: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub endIndex: u16_,
    #[doc = "< Pointer to the next block."]
    pub next: *mut CWDH_s,
    #[doc = "< Table of character width information structures."]
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
impl Default for tag_CWDH_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Font character map type."]
pub type CMAP_s = tag_CMAP_s;
#[doc = " Font character map structure."]
#[repr(C)]
pub struct tag_CMAP_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub codeBegin: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub codeEnd: u16_,
    #[doc = "< Mapping method."]
    pub mappingMethod: u16_,
    pub reserved: u16_,
    #[doc = "< Pointer to the next map."]
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    #[doc = "< For CMAP_TYPE_DIRECT: index of the first glyph."]
    pub indexOffset: __BindgenUnionField<u16_>,
    #[doc = "< For CMAP_TYPE_TABLE: table of glyph indices."]
    pub indexTable: __BindgenUnionField<[u16_; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[doc = " For CMAP_TYPE_SCAN: Mapping data."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Number of pairs."]
    pub nScanEntries: u16_,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[doc = " Mapping pairs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Unicode codepoint."]
    pub code: u16_,
    #[doc = "< Mapped glyph index."]
    pub glyphIndex: u16_,
}
impl Default for tag_CMAP_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tag_CMAP_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Font information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FINF_s {
    #[doc = "< Signature (FINF)."]
    pub signature: u32_,
    #[doc = "< Section size."]
    pub sectionSize: u32_,
    #[doc = "< Font type"]
    pub fontType: u8_,
    #[doc = "< Line feed vertical distance."]
    pub lineFeed: u8_,
    #[doc = "< Glyph index of the replacement character."]
    pub alterCharIndex: u16_,
    #[doc = "< Default character width information."]
    pub defaultWidth: charWidthInfo_s,
    #[doc = "< Font encoding (?)"]
    pub encoding: u8_,
    #[doc = "< Pointer to texture sheet information."]
    pub tglp: *mut TGLP_s,
    #[doc = "< Pointer to the first character width information block."]
    pub cwdh: *mut CWDH_s,
    #[doc = "< Pointer to the first character map."]
    pub cmap: *mut CMAP_s,
    #[doc = "< Font height."]
    pub height: u8_,
    #[doc = "< Font width."]
    pub width: u8_,
    #[doc = "< Font ascent."]
    pub ascent: u8_,
    pub padding: u8_,
}
impl Default for FINF_s {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " Font glyph position structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s {
    #[doc = "< Texture sheet index to use to render the glyph."]
    pub sheetIndex: ::libc::c_int,
    #[doc = "< Horizontal offset to draw the glyph width."]
    pub xOffset: f32,
    #[doc = "< Horizontal distance to advance after drawing the glyph."]
    pub xAdvance: f32,
    #[doc = "< Glyph width."]
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[doc = " Texture coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[doc = " Vertex coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
pub type C3D_IVec = u32_;
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = " @brief Raw access"]
    pub c: [f32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[doc = " @brief Vector access"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = " @brief Quaternion access"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
impl Default for C3D_FVec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = " @struct C3D_FQuat"]
#[doc = " @brief Float quaternion. See @ref C3D_FVec."]
pub type C3D_FQuat = C3D_FVec;
#[doc = " @struct C3D_Mtx"]
#[doc = " @brief Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
    _bindgen_union_align: [u32; 16usize],
}
impl Default for C3D_Mtx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    #[doc = "@brief Transposes the matrix. Row => Column, and vice versa."]
    #[doc = "@param[in,out] out     Output matrix."]
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Multiply two matrices"]
    #[doc = " @param[out] out Output matrix"]
    #[doc = " @param[in]  a   Multiplicand"]
    #[doc = " @param[in]  b   Multiplier"]
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Inverse a matrix"]
    #[doc = " @param[in,out] out Matrix to inverse"]
    #[doc = " @retval 0.0f Degenerate matrix (no inverse)"]
    #[doc = " @return determinant"]
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
extern "C" {
    #[doc = " @brief Multiply 3x3 matrix by a FVec3"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Multiply 4x4 matrix by a FVec4"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Get 4x4 matrix equivalent to Quaternion"]
    #[doc = " @param[out] m Output matrix"]
    #[doc = " @param[in]  q Input Quaternion"]
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
extern "C" {
    #[doc = " @brief 3D translation"]
    #[doc = " @param[in,out] mtx Matrix to translate"]
    #[doc = " @param[in]     x            X component to translate"]
    #[doc = " @param[in]     y            Y component to translate"]
    #[doc = " @param[in]     z            Z component to translate"]
    #[doc = " @param[in]     bRightSide   Whether to transform from the right side"]
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Scale"]
    #[doc = " @param[in,out] mtx Matrix to scale"]
    #[doc = " @param[in]     x   X component to scale"]
    #[doc = " @param[in]     y   Y component to scale"]
    #[doc = " @param[in]     z   Z component to scale"]
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " @brief 3D Rotation"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     axis       Axis about which to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the X axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Y axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Z axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief Orthogonal projection"]
    #[doc = " @param[out] mtx Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_OrthoTilt"]
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection"]
    #[doc = " @note Typically you will use iod to mean the distance between the eyes. Plug"]
    #[doc = "       in -iod for the left eye and iod for the right eye."]
    #[doc = " @note The focal length is defined by screen. If objects are further than this,"]
    #[doc = "       they will appear to be inside the screen. If objects are closer than this,"]
    #[doc = "       they will appear to pop out of the screen. Objects at this distance appear"]
    #[doc = "       to be at the screen."]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Orthogonal projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Ortho"]
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @note See the notes for @ref Mtx_PerspStereo"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Look-At matrix, based on DirectX implementation"]
    #[doc = " @note See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342"]
    #[doc = " @param[out] out            Output matrix."]
    #[doc = " @param[in]  cameraPosition Position of the intended camera in 3D space."]
    #[doc = " @param[in]  cameraTarget   Position of the intended target the camera is supposed to face in 3D space."]
    #[doc = " @param[in]  cameraUpVector The vector that points straight up depending on the camera's \"Up\" direction."]
    #[doc = " @param[in]  isLeftHanded   Whether to build a LH projection"]
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
impl Default for C3D_MtxStack {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: ::libc::c_uint = 0;
pub const C3D_UNSIGNED_SHORT: ::libc::c_uint = 1;
pub type _bindgen_ty_38 = ::libc::c_uint;
extern "C" {
    pub fn C3D_Init(cmdBufSize: size_t) -> bool;
}
extern "C" {
    pub fn C3D_Fini();
}
extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
extern "C" {
    pub fn C3D_ImmDrawEnd();
}
extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for C3D_TexEnv__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for C3D_TexEnv {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uint;
extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
impl Default for C3D_TexCube {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
    _bindgen_union_align: u32,
}
impl Default for C3D_Tex__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
impl Default for C3D_Tex__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl Default for C3D_Tex__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for C3D_Tex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> size_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: size_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: size_t) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl Default for C3D_TexInitParams {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u32 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
impl Default for C3D_ProcTexColorLut {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for C3D_ProcTex__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
impl Default for C3D_ProcTex__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
impl Default for C3D_ProcTex__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
impl Default for C3D_ProcTex__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for C3D_ProcTex__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for C3D_ProcTex__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for C3D_ProcTex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const C3D_ProcTex_U: ::libc::c_uint = 1;
pub const C3D_ProcTex_V: ::libc::c_uint = 2;
pub const C3D_ProcTex_UV: ::libc::c_uint = 3;
pub type _bindgen_ty_39 = ::libc::c_uint;
extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
impl Default for C3D_LightLut {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
impl Default for C3D_LightLutDA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
extern "C" {
    pub fn LightLut_FromArray(lut: *mut C3D_LightLut, data: *mut f32);
}
extern "C" {
    pub fn LightLut_FromFunc(
        lut: *mut C3D_LightLut,
        func: C3D_LightLutFunc,
        param: f32,
        negative: bool,
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
impl Default for C3D_LightEnv_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
impl Default for C3D_Light_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
impl Default for C3D_FogLut {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
extern "C" {
    pub fn C3D_GasBeginAcc();
}
extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl Default for C3D_FrameBuf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uint;
extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
impl Default for C3D_RenderTarget_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const C3D_FRAME_SYNCDRAW: ::libc::c_uint = 1;
pub const C3D_FRAME_NONBLOCK: ::libc::c_uint = 2;
pub type _bindgen_ty_43 = ::libc::c_uint;
extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
extern "C" {
    pub fn C3D_FrameSync();
}
extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
    _bindgen_union_align: u32,
}
impl Default for C3D_DEPTHTYPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
pub type FILE = __FILE;
#[doc = " @brief Subtexture"]
#[doc = "  @note If top > bottom, the subtexture is rotated 1/4 revolution counter-clockwise"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Tex3DS_SubTexture {
    #[doc = "< Sub-texture width (pixels)"]
    pub width: u16_,
    #[doc = "< Sub-texture height (pixels)"]
    pub height: u16_,
    #[doc = "< Left u-coordinate"]
    pub left: f32,
    #[doc = "< Top v-coordinate"]
    pub top: f32,
    #[doc = "< Right u-coordinate"]
    pub right: f32,
    #[doc = "< Bottom v-coordinate"]
    pub bottom: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C2D_DrawParams {
    pub pos: C2D_DrawParams__bindgen_ty_1,
    pub center: C2D_DrawParams__bindgen_ty_2,
    pub depth: f32,
    pub angle: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C2D_DrawParams__bindgen_ty_2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C2D_Tint {
    #[doc = "< RGB tint color and Alpha transparency"]
    pub color: u32_,
    #[doc = "< Blending strength of the tint color (0.0~1.0)"]
    pub blend: f32,
}
#[doc = "< Top left corner"]
pub const C2D_TopLeft: C2D_Corner = 0;
#[doc = "< Top right corner"]
pub const C2D_TopRight: C2D_Corner = 1;
#[doc = "< Bottom left corner"]
pub const C2D_BotLeft: C2D_Corner = 2;
#[doc = "< Bottom right corner"]
pub const C2D_BotRight: C2D_Corner = 3;
pub type C2D_Corner = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Image {
    pub tex: *mut C3D_Tex,
    pub subtex: *const Tex3DS_SubTexture,
}
impl Default for C2D_Image {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct C2D_ImageTint {
    pub corners: [C2D_Tint; 4usize],
}
extern "C" {
    #[doc = " @brief Initialize citro2d"]
    #[doc = "  @param[in] maxObjects Maximum number of 2D objects that can be drawn per frame."]
    #[doc = "  @remarks Pass C2D_DEFAULT_MAX_OBJECTS as a starting point."]
    #[doc = "  @returns true on success, false on failure"]
    pub fn C2D_Init(maxObjects: size_t) -> bool;
}
extern "C" {
    #[doc = " @brief Deinitialize citro2d"]
    pub fn C2D_Fini();
}
extern "C" {
    #[doc = " @brief Prepares the GPU for rendering 2D content"]
    #[doc = "  @remarks This needs to be done only once in the program if citro2d is the sole user of the GPU."]
    pub fn C2D_Prepare();
}
extern "C" {
    #[doc = " @brief Ensures all 2D objects so far have been drawn"]
    pub fn C2D_Flush();
}
extern "C" {
    #[doc = " @brief Configures the size of the 2D scene."]
    #[doc = "  @param[in] width The width of the scene, in pixels."]
    #[doc = "  @param[in] height The height of the scene, in pixels."]
    #[doc = "  @param[in] tilt Whether the scene is tilted like the 3DS's sideways screens."]
    pub fn C2D_SceneSize(width: u32_, height: u32_, tilt: bool);
}
extern "C" {
    #[doc = " @brief Resets the model transformation matrix."]
    pub fn C2D_ViewReset();
}
extern "C" {
    #[doc = " @brief Saves the current model transformation matrix."]
    #[doc = " @param[out] matrix Pointer to save the current matrix to"]
    pub fn C2D_ViewSave(matrix: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Restores a previously saved model transformation matrix."]
    #[doc = " @param[in] matrix Pointer to matrix to restor"]
    pub fn C2D_ViewRestore(matrix: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Translates everything drawn via the model matrix."]
    #[doc = " @param[in] x Translation in the x direction"]
    #[doc = " @param[in] y Translation in the y direction"]
    pub fn C2D_ViewTranslate(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Rotates everything drawn via the model matrix."]
    #[doc = " @param[in] rotation Rotation in the counterclockwise direction in radians"]
    pub fn C2D_ViewRotate(rotation: f32);
}
extern "C" {
    #[doc = " @brief Shears everything drawn via the model matrix."]
    #[doc = " @param[in] x Shear factor in the x direction"]
    #[doc = " @param[in] y Shear factor in the y direction"]
    pub fn C2D_ViewShear(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Scales everything drawn via the model matrix."]
    #[doc = " @param[in] x Scale factor in the x direction"]
    #[doc = " @param[in] y Scale factor in the y direction"]
    pub fn C2D_ViewScale(x: f32, y: f32);
}
extern "C" {
    #[doc = " @brief Helper function to create a render target for a screen"]
    #[doc = "  @param[in] screen Screen (GFX_TOP or GFX_BOTTOM)"]
    #[doc = "  @param[in] side Side (GFX_LEFT or GFX_RIGHT)"]
    #[doc = "  @returns citro3d render target object"]
    pub fn C2D_CreateScreenTarget(screen: gfxScreen_t, side: gfx3dSide_t) -> *mut C3D_RenderTarget;
}
extern "C" {
    #[doc = " @brief Helper function to clear a rendertarget using the specified color"]
    #[doc = "  @param[in] target Render target to clear"]
    #[doc = "  @param[in] color 32-bit RGBA color value to fill the target with"]
    pub fn C2D_TargetClear(target: *mut C3D_RenderTarget, color: u32_);
}
extern "C" {
    #[doc = " @brief Configures the fading color"]
    #[doc = "  @param[in] color 32-bit RGBA color value to be used as the fading color (0 by default)"]
    #[doc = "  @remark The alpha component of the color is used as the strength of the fading color."]
    #[doc = "          If alpha is zero, the fading color has no effect. If it is the highest value,"]
    #[doc = "          the rendered pixels will all have the fading color. Everything inbetween is"]
    #[doc = "          rendered as a blend of the original pixel color and the fading color."]
    pub fn C2D_Fade(color: u32_);
}
extern "C" {
    #[doc = " @brief Draws an image using the GPU (variant accepting C2D_DrawParams)"]
    #[doc = "  @param[in] img Handle of the image to draw"]
    #[doc = "  @param[in] params Parameters with which to draw the image"]
    #[doc = "  @param[in] tint Tint parameters to apply to the image (optional, can be null)"]
    #[doc = "  @returns true on success, false on failure"]
    pub fn C2D_DrawImage(
        img: C2D_Image,
        params: *const C2D_DrawParams,
        tint: *const C2D_ImageTint,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain triangle using the GPU"]
    #[doc = "  @param[in] x0 X coordinate of the first vertex of the triangle"]
    #[doc = "  @param[in] y0 Y coordinate of the first vertex of the triangle"]
    #[doc = "  @param[in] clr0 32-bit RGBA color of the first vertex of the triangle"]
    #[doc = "  @param[in] x1 X coordinate of the second vertex of the triangle"]
    #[doc = "  @param[in] y1 Y coordinate of the second vertex of the triangle"]
    #[doc = "  @param[in] clr1 32-bit RGBA color of the second vertex of the triangle"]
    #[doc = "  @param[in] x2 X coordinate of the third vertex of the triangle"]
    #[doc = "  @param[in] y2 Y coordinate of the third vertex of the triangle"]
    #[doc = "  @param[in] clr2 32-bit RGBA color of the third vertex of the triangle"]
    #[doc = "  @param[in] depth Depth value to draw the triangle with"]
    pub fn C2D_DrawTriangle(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        x2: f32,
        y2: f32,
        clr2: u32_,
        depth: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain line using the GPU"]
    #[doc = "  @param[in] x0 X coordinate of the first vertex of the line"]
    #[doc = "  @param[in] y0 Y coordinate of the first vertex of the line"]
    #[doc = "  @param[in] clr0 32-bit RGBA color of the first vertex of the line"]
    #[doc = "  @param[in] x1 X coordinate of the second vertex of the line"]
    #[doc = "  @param[in] y1 Y coordinate of the second vertex of the line"]
    #[doc = "  @param[in] clr1 32-bit RGBA color of the second vertex of the line"]
    #[doc = "  @param[in] thickness Thickness, in pixels, of the line"]
    #[doc = "  @param[in] depth Depth value to draw the line with"]
    pub fn C2D_DrawLine(
        x0: f32,
        y0: f32,
        clr0: u32_,
        x1: f32,
        y1: f32,
        clr1: u32_,
        thickness: f32,
        depth: f32,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws a plain rectangle using the GPU"]
    #[doc = "  @param[in] x X coordinate of the top-left vertex of the rectangle"]
    #[doc = "  @param[in] y Y coordinate of the top-left vertex of the rectangle"]
    #[doc = "  @param[in] z Z coordinate (depth value) to draw the rectangle with"]
    #[doc = "  @param[in] w Width of the rectangle"]
    #[doc = "  @param[in] h Height of the rectangle"]
    #[doc = "  @param[in] clr0 32-bit RGBA color of the top-left corner of the rectangle"]
    #[doc = "  @param[in] clr1 32-bit RGBA color of the top-right corner of the rectangle"]
    #[doc = "  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the rectangle"]
    #[doc = "  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the rectangle"]
    pub fn C2D_DrawRectangle(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief Draws an ellipse using the GPU"]
    #[doc = "  @param[in] x X coordinate of the top-left vertex of the ellipse"]
    #[doc = "  @param[in] y Y coordinate of the top-left vertex of the ellipse"]
    #[doc = "  @param[in] z Z coordinate (depth value) to draw the ellipse with"]
    #[doc = "  @param[in] w Width of the ellipse"]
    #[doc = "  @param[in] h Height of the ellipse"]
    #[doc = "  @param[in] clr0 32-bit RGBA color of the top-left corner of the ellipse"]
    #[doc = "  @param[in] clr1 32-bit RGBA color of the top-right corner of the ellipse"]
    #[doc = "  @param[in] clr2 32-bit RGBA color of the bottom-left corner of the ellipse"]
    #[doc = "  @param[in] clr3 32-bit RGBA color of the bottom-right corner of the ellipse"]
    #[doc = "  @note Switching to and from \"circle mode\" internally requires an expensive state change. As such, the recommended usage of this feature is to draw all non-circular objects first, then draw all circular objects."]
    pub fn C2D_DrawEllipse(
        x: f32,
        y: f32,
        z: f32,
        w: f32,
        h: f32,
        clr0: u32_,
        clr1: u32_,
        clr2: u32_,
        clr3: u32_,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_SpriteSheet_s {
    _unused: [u8; 0],
}
pub type C2D_SpriteSheet = *mut C2D_SpriteSheet_s;
extern "C" {
    #[doc = " @brief Load a sprite sheet from file"]
    #[doc = "  @param[in] filename Name of the sprite sheet file (.t3x)"]
    #[doc = "  @returns Sprite sheet handle"]
    #[doc = "  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoad(filename: *const ::libc::c_char) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load a sprite sheet from memory"]
    #[doc = "  @param[in] data Data to load"]
    #[doc = "  @param[in] size Size of the data to load"]
    #[doc = "  @returns Sprite sheet handle"]
    #[doc = "  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoadFromMem(data: *const ::libc::c_void, size: size_t)
        -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load sprite sheet from file descriptor"]
    #[doc = "  @param[in] fd File descriptor used to load data"]
    #[doc = "  @returns Sprite sheet handle"]
    #[doc = "  @retval NULL Error"]
    pub fn C2D_SpriteSheetFromFD(fd: ::libc::c_int) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Load sprite sheet from stdio file handle"]
    #[doc = "  @param[in] f File handle used to load data"]
    #[doc = "  @returns Sprite sheet handle"]
    #[doc = "  @retval NULL Error"]
    pub fn C2D_SpriteSheetLoadFromHandle(f: *mut FILE) -> C2D_SpriteSheet;
}
extern "C" {
    #[doc = " @brief Free a sprite sheet"]
    #[doc = "  @param[in] sheet Sprite sheet handle"]
    pub fn C2D_SpriteSheetFree(sheet: C2D_SpriteSheet);
}
extern "C" {
    #[doc = " @brief Retrieves the number of sprites in the specified sprite sheet"]
    #[doc = "  @param[in] sheet Sprite sheet handle"]
    #[doc = "  @returns Number of sprites"]
    pub fn C2D_SpriteSheetCount(sheet: C2D_SpriteSheet) -> size_t;
}
extern "C" {
    #[doc = " @brief Retrieves the specified image from the specified sprite sheet"]
    #[doc = "  @param[in] sheet Sprite sheet handle"]
    #[doc = "  @param[in] index Index of the image to retrieve"]
    #[doc = "  @returns Image object"]
    pub fn C2D_SpriteSheetGetImage(sheet: C2D_SpriteSheet, index: size_t) -> C2D_Image;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Sprite {
    pub image: C2D_Image,
    pub params: C2D_DrawParams,
}
impl Default for C2D_Sprite {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Font_s {
    _unused: [u8; 0],
}
pub type C2D_Font = *mut C2D_Font_s;
extern "C" {
    #[doc = " @brief Load a font from a file"]
    #[doc = " @param[in] filename Name of the font file (.bcfnt)"]
    #[doc = " @returns Font handle"]
    #[doc = " @retval NULL Error"]
    pub fn C2D_FontLoad(filename: *const ::libc::c_char) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load a font from memory"]
    #[doc = " @param[in] data Data to load"]
    #[doc = " @param[in] size Size of the data to load"]
    #[doc = " @returns Font handle"]
    #[doc = " @retval NULL Error"]
    pub fn C2D_FontLoadFromMem(data: *const ::libc::c_void, size: size_t) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load a font from file descriptor"]
    #[doc = " @param[in] fd File descriptor used to load data"]
    #[doc = " @returns Font handle"]
    #[doc = " @retval NULL Error"]
    pub fn C2D_FontLoadFromFD(fd: ::libc::c_int) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load font from stdio file handle"]
    #[doc = "  @param[in] f File handle used to load data"]
    #[doc = "  @returns Font handle"]
    #[doc = "  @retval NULL Error"]
    pub fn C2D_FontLoadFromHandle(f: *mut FILE) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Load corresponding font from system archive"]
    #[doc = "  @param[in] region Region to get font from"]
    #[doc = "  @returns Font handle"]
    #[doc = "  @retval NULL Error"]
    #[doc = "  @remark JPN, USA, EUR, and AUS all use the same font."]
    pub fn C2D_FontLoadSystem(region: CFG_Region) -> C2D_Font;
}
extern "C" {
    #[doc = " @brief Free a font"]
    #[doc = " @param[in] font Font handle"]
    pub fn C2D_FontFree(font: C2D_Font);
}
extern "C" {
    #[doc = " @brief Find the glyph index of a codepoint, or returns the default"]
    #[doc = " @param[in] font Font to search, or NULL for system font"]
    #[doc = " @param[in] codepoint Codepoint to search for"]
    #[doc = " @returns Glyph index"]
    #[doc = " @retval font->cfnt->finf.alterCharIndex The codepoint does not exist in the font"]
    pub fn C2D_FontGlyphIndexFromCodePoint(font: C2D_Font, codepoint: u32_) -> ::libc::c_int;
}
extern "C" {
    #[doc = " @brief Get character width info for a given index"]
    #[doc = " @param[in] font Font to read from, or NULL for system font"]
    #[doc = " @param[in] glyphIndex Index to get the width of"]
    #[doc = " @returns Width info for glyph"]
    pub fn C2D_FontGetCharWidthInfo(
        font: C2D_Font,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    #[doc = " @brief Calculate glyph position of given index"]
    #[doc = " @param[in] font Font to read from, or NULL for system font"]
    #[doc = " @param[out] out Glyph position"]
    #[doc = " @param[in] glyphIndex Index to get position of"]
    #[doc = " @param[in] flags Misc flags"]
    #[doc = " @param[in] scaleX Size to scale in X"]
    #[doc = " @param[in] scaleY Size to scale in Y"]
    pub fn C2D_FontCalcGlyphPos(
        font: C2D_Font,
        out: *mut fontGlyphPos_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    #[doc = " @brief Get the font info structure associated with the font"]
    #[doc = " @param[in] font Font to read from, or NULL for the system font"]
    #[doc = " @returns FINF associated with the font"]
    pub fn C2D_FontGetInfo(font: C2D_Font) -> *mut FINF_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_TextBuf_s {
    _unused: [u8; 0],
}
pub type C2D_TextBuf = *mut C2D_TextBuf_s;
#[doc = " Text object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C2D_Text {
    #[doc = "< Buffer associated with the text."]
    pub buf: C2D_TextBuf,
    #[doc = "< Reserved for internal use."]
    pub begin: size_t,
    #[doc = "< Reserved for internal use."]
    pub end: size_t,
    #[doc = "< Width of the text in pixels, according to 1x scale metrics."]
    pub width: f32,
    #[doc = "< Number of lines in the text."]
    pub lines: u32_,
    #[doc = "< Number of words in the text."]
    pub words: u32_,
    #[doc = "< Font used to draw the text, or NULL for system font"]
    pub font: C2D_Font,
}
impl Default for C2D_Text {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[doc = "< Matches the Y coordinate with the baseline of the font."]
pub const C2D_AtBaseline: ::libc::c_uint = 1;
#[doc = "< Draws text with color. Requires a u32 color value."]
pub const C2D_WithColor: ::libc::c_uint = 2;
#[doc = "< Draws text aligned to the left. This is the default."]
pub const C2D_AlignLeft: ::libc::c_uint = 0;
#[doc = "< Draws text aligned to the right."]
pub const C2D_AlignRight: ::libc::c_uint = 4;
#[doc = "< Draws text centered."]
pub const C2D_AlignCenter: ::libc::c_uint = 8;
#[doc = "< Draws text justified. When C2D_WordWrap is not specified, right edge is x + scaleX*text->width. Otherwise, right edge is x + the width specified for those values."]
pub const C2D_AlignJustified: ::libc::c_uint = 12;
#[doc = "< Bitmask for alignment values."]
pub const C2D_AlignMask: ::libc::c_uint = 12;
#[doc = "< Draws text with wrapping of full words before specified width. Requires a float value, passed after color if C2D_WithColor is specified."]
pub const C2D_WordWrap: ::libc::c_uint = 16;
pub type _bindgen_ty_44 = ::libc::c_uint;
extern "C" {
    #[doc = " @brief Creates a new text buffer."]
    #[doc = "  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer."]
    #[doc = "  @returns Text buffer handle (or NULL on failure)."]
    pub fn C2D_TextBufNew(maxGlyphs: size_t) -> C2D_TextBuf;
}
extern "C" {
    #[doc = " @brief Resizes a text buffer."]
    #[doc = "  @param[in] buf Text buffer to resize."]
    #[doc = "  @param[in] maxGlyphs Maximum number of glyphs that can be stored in the buffer."]
    #[doc = "  @returns New text buffer handle (or NULL on failure)."]
    #[doc = "  @remarks If successful, old text buffer handle becomes invalid."]
    pub fn C2D_TextBufResize(buf: C2D_TextBuf, maxGlyphs: size_t) -> C2D_TextBuf;
}
extern "C" {
    #[doc = " @brief Deletes a text buffer."]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @remarks This also invalidates all text objects previously created with this buffer."]
    pub fn C2D_TextBufDelete(buf: C2D_TextBuf);
}
extern "C" {
    #[doc = " @brief Clears all stored text in a buffer."]
    #[doc = "  @param[in] buf Text buffer handle."]
    pub fn C2D_TextBufClear(buf: C2D_TextBuf);
}
extern "C" {
    #[doc = " @brief Retrieves the number of glyphs stored in a text buffer."]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @returns The number of glyphs."]
    pub fn C2D_TextBufGetNumGlyphs(buf: C2D_TextBuf) -> size_t;
}
extern "C" {
    #[doc = " @brief Parses and adds a single line of text to a text buffer."]
    #[doc = "  @param[out] text Pointer to text object to store information in."]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @param[in] str String to parse."]
    #[doc = "  @param[in] lineNo Line number assigned to the text (used to calculate vertical position)."]
    #[doc = "  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\"."]
    #[doc = "  @returns On success, a pointer to the character on which string processing stopped, which"]
    #[doc = "           can be a newline ('\\n'; indicating that's where the line ended), the null character"]
    #[doc = "           ('\\0'; indicating the end of the string was reached), or any other character"]
    #[doc = "           (indicating the text buffer is full and no more glyphs can be added)."]
    #[doc = "           On failure, NULL."]
    pub fn C2D_TextParseLine(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds a single line of text to a text buffer."]
    #[doc = "  @param[out] text Pointer to text object to store information in."]
    #[doc = "  @param[in] font Font to get glyphs from, or null for system font"]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @param[in] str String to parse."]
    #[doc = "  @param[in] lineNo Line number assigned to the text (used to calculate vertical position)."]
    #[doc = "  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\"."]
    #[doc = "  @returns On success, a pointer to the character on which string processing stopped, which"]
    #[doc = "           can be a newline ('\\n'; indicating that's where the line ended), the null character"]
    #[doc = "           ('\\0'; indicating the end of the string was reached), or any other character"]
    #[doc = "           (indicating the text buffer is full and no more glyphs can be added)."]
    #[doc = "           On failure, NULL."]
    pub fn C2D_TextFontParseLine(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
        lineNo: u32_,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds arbitrary text (including newlines) to a text buffer."]
    #[doc = "  @param[out] text Pointer to text object to store information in."]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @param[in] str String to parse."]
    #[doc = "  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\"."]
    #[doc = "  @returns On success, a pointer to the character on which string processing stopped, which"]
    #[doc = "           can be the null character ('\\0'; indicating the end of the string was reached),"]
    #[doc = "           or any other character (indicating the text buffer is full and no more glyphs can be added)."]
    #[doc = "           On failure, NULL."]
    pub fn C2D_TextParse(
        text: *mut C2D_Text,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Parses and adds arbitrary text (including newlines) to a text buffer."]
    #[doc = "  @param[out] text Pointer to text object to store information in."]
    #[doc = "  @param[in] font Font to get glyphs from, or null for system font"]
    #[doc = "  @param[in] buf Text buffer handle."]
    #[doc = "  @param[in] str String to parse."]
    #[doc = "  @remarks Whitespace doesn't add any glyphs to the text buffer and is thus \"free\"."]
    #[doc = "  @returns On success, a pointer to the character on which string processing stopped, which"]
    #[doc = "           can be the null character ('\\0'; indicating the end of the string was reached),"]
    #[doc = "           or any other character (indicating the text buffer is full and no more glyphs can be added)."]
    #[doc = "           On failure, NULL."]
    pub fn C2D_TextFontParse(
        text: *mut C2D_Text,
        font: C2D_Font,
        buf: C2D_TextBuf,
        str_: *const ::libc::c_char,
    ) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " @brief Optimizes a text object in order to be drawn more efficiently."]
    #[doc = "  @param[in] text Pointer to text object."]
    pub fn C2D_TextOptimize(text: *const C2D_Text);
}
extern "C" {
    #[doc = " @brief Retrieves the total dimensions of a text object."]
    #[doc = "  @param[in] text Pointer to text object."]
    #[doc = "  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font."]
    #[doc = "  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font."]
    #[doc = "  @param[out] outWidth (optional) Variable in which to store the width of the text."]
    #[doc = "  @param[out] outHeight (optional) Variable in which to store the height of the text."]
    pub fn C2D_TextGetDimensions(
        text: *const C2D_Text,
        scaleX: f32,
        scaleY: f32,
        outWidth: *mut f32,
        outHeight: *mut f32,
    );
}
extern "C" {
    #[doc = " @brief Draws text using the GPU."]
    #[doc = "  @param[in] text Pointer to text object."]
    #[doc = "  @param[in] flags Text drawing flags."]
    #[doc = "  @param[in] x Horizontal position to draw the text on."]
    #[doc = "  @param[in] y Vertical position to draw the text on. If C2D_AtBaseline is not specified (default), this"]
    #[doc = "               is the top left corner of the block of text; otherwise this is the position of the baseline"]
    #[doc = "               of the first line of text."]
    #[doc = "  @param[in] z Depth value of the text. If unsure, pass 0.0f."]
    #[doc = "  @param[in] scaleX Horizontal size of the font. 1.0f corresponds to the native size of the font."]
    #[doc = "  @param[in] scaleY Vertical size of the font. 1.0f corresponds to the native size of the font."]
    #[doc = "  @remarks The default 3DS system font has a glyph height of 30px, and the baseline is at 25px."]
    pub fn C2D_DrawText(
        text: *const C2D_Text,
        flags: u32_,
        x: f32,
        y: f32,
        z: f32,
        scaleX: f32,
        scaleY: f32,
        ...
    );
}
